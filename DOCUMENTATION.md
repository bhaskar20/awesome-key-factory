# React Query Key Factory - Complete Documentation

## Table of Contents

1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Quick Start](#quick-start)
4. [Core Concepts](#core-concepts)
5. [Usage Guide](#usage-guide)
6. [API Reference](#api-reference)
7. [Examples](#examples)
8. [TypeScript Support](#typescript-support)
9. [Best Practices](#best-practices)
10. [FAQ](#faq)

---

## Introduction

`react-query-key-factory` is a type-safe utility library for managing React Query keys in TypeScript applications. It provides a structured, hierarchical approach to defining query keys with full type safety and autocomplete support.

### Why Use This Library?

- **Type Safety**: Get compile-time errors for typos and incorrect key usage
- **Autocomplete**: Full IDE support with intelligent suggestions
- **Organization**: Hierarchical structure keeps your keys organized
- **Flexibility**: Support for nested structures, parameters, and array shorthand
- **Maintainability**: Centralized key management makes refactoring easier

---

## Installation

### Using Yarn (Recommended)

```bash
yarn add react-query-key-factory
```

### Using npm

```bash
npm install react-query-key-factory
```

### Peer Dependencies

This library requires TypeScript version 4.0.0 or higher.

---

## Quick Start

### Basic Setup

```typescript
import { createKeyFactory } from 'react-query-key-factory';

const queryKeys = createKeyFactory('app', {
  users: {
    all: () => [],
    detail: (params: { id: string }) => [params.id],
  },
  posts: {
    all: () => [],
    detail: (params: { id: string }) => [params.id],
  },
});

// Usage in React Query
useQuery({
  queryKey: queryKeys.users.detail({ id: '123' }),
  queryFn: () => fetchUser('123'),
});
```

---

## Core Concepts

### 1. Base Key

The base key is the root identifier for all keys generated by the factory. It's the first element in every generated key array.

```typescript
const keys = createKeyFactory('myApp', { ... });
// All keys will start with 'myApp'
```

### 2. Schema Structure

The schema defines the hierarchical structure of your keys. It can contain:
- **Functions**: Generate dynamic keys based on parameters
- **Nested Objects**: Create hierarchical key structures
- **Arrays**: Shorthand for static key lists

### 3. Key Generation

Keys are generated as arrays of strings, following the pattern:
```
[baseKey, ...path, ...additionalKeys]
```

---

## Usage Guide

### Basic Usage

#### Simple Key with Function

```typescript
const keys = createKeyFactory('base', {
  items: (params: {}) => ['list'],
});

keys.items({}) // => ['base', 'items', 'list']
```

#### Nested Structure

```typescript
const keys = createKeyFactory('app', {
  users: {
    all: () => [],
    detail: (params: { id: string }) => [params.id],
  },
});

keys.users.all({}) // => ['app', 'users', 'all']
keys.users.detail({ id: '123' }) // => ['app', 'users', 'detail', '123']
keys.users() // => ['app', 'users'] (access intermediate level)
```

#### Array Shorthand

For static keys, you can use arrays instead of functions:

```typescript
const keys = createKeyFactory('shop', {
  products: {
    list: ['all'], // Equivalent to () => ['all']
    featured: ['featured', 'items'],
  },
});

keys.products.list() // => ['shop', 'products', 'list', 'all']
keys.products.featured() // => ['shop', 'products', 'featured', 'featured', 'items']
```

### Advanced Patterns

#### Deep Nesting

```typescript
const keys = createKeyFactory('api', {
  v1: {
    users: {
      posts: {
        comments: (params: { postId: string }) => [params.postId],
      },
    },
  },
});

keys.v1.users.posts.comments({ postId: '123' })
// => ['api', 'v1', 'users', 'posts', 'comments', '123']

// Access any intermediate level
keys.v1.users.posts() // => ['api', 'v1', 'users', 'posts']
keys.v1.users() // => ['api', 'v1', 'users']
keys.v1() // => ['api', 'v1']
```

#### Mixed Function and Array Syntax

```typescript
const keys = createKeyFactory('shop', {
  products: {
    list: ['all'], // Array shorthand
    byCategory: (params: { category: string }) => [params.category], // Function
    byId: (params: { id: string }) => [params.id], // Function
  },
  cart: ['items'], // Array shorthand
});

keys.products.list() // => ['shop', 'products', 'list', 'all']
keys.products.byCategory({ category: 'electronics' })
// => ['shop', 'products', 'byCategory', 'electronics']
keys.cart() // => ['shop', 'cart', 'items']
```

---

## API Reference

### `createKeyFactory<BaseKey, Schema>(baseKey, schema)`

Creates a type-safe key factory for React Query keys.

#### Parameters

- **`baseKey`** (`BaseKey extends string`): The base key that will be prepended to all generated keys
- **`schema`** (`Schema extends Record<string, any>`): An object defining the key structure

#### Returns

A factory object (`KeyFactory<Schema, BaseKey>`) where:
- Each leaf node (function or array) can be called to generate a key
- Each intermediate node can be called to get its path

#### Type Parameters

- **`BaseKey`**: The type of the base key string
- **`Schema`**: The type of the schema object

---

## Examples

### Real-World React Query Setup

```typescript
import { createKeyFactory } from 'react-query-key-factory';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Define your key factory
const queryKeys = createKeyFactory('app', {
  users: {
    all: () => [],
    lists: () => ['list'],
    detail: (params: { id: string }) => [params.id],
    posts: (params: { userId: string }) => [params.userId, 'posts'],
  },
  posts: {
    all: () => [],
    detail: (params: { id: string }) => [params.id],
    comments: (params: { postId: string }) => [params.postId, 'comments'],
  },
});

// Use in components
function UserDetail({ userId }: { userId: string }) {
  const { data, isLoading } = useQuery({
    queryKey: queryKeys.users.detail({ id: userId }),
    queryFn: () => fetchUser(userId),
  });

  const { data: posts } = useQuery({
    queryKey: queryKeys.users.posts({ userId }),
    queryFn: () => fetchUserPosts(userId),
  });

  // ...
}

// Use in mutations for invalidation
function useCreatePost() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createPost,
    onSuccess: (data) => {
      // Invalidate related queries
      queryClient.invalidateQueries({
        queryKey: queryKeys.posts.all({}),
      });
      queryClient.invalidateQueries({
        queryKey: queryKeys.users.posts({ userId: data.userId }),
      });
    },
  });
}
```

### E-commerce Application

```typescript
const queryKeys = createKeyFactory('shop', {
  products: {
    all: () => [],
    byCategory: (params: { category: string }) => [params.category],
    byId: (params: { id: string }) => [params.id],
    search: (params: { query: string }) => ['search', params.query],
  },
  cart: {
    items: () => [],
    count: () => ['count'],
  },
  orders: {
    all: () => [],
    byId: (params: { id: string }) => [params.id],
    byStatus: (params: { status: string }) => [params.status],
  },
});

// Usage
useQuery({
  queryKey: queryKeys.products.byCategory({ category: 'electronics' }),
  queryFn: () => fetchProductsByCategory('electronics'),
});

useQuery({
  queryKey: queryKeys.products.search({ query: 'laptop' }),
  queryFn: () => searchProducts('laptop'),
});
```

### API Versioning

```typescript
const queryKeys = createKeyFactory('api', {
  v1: {
    users: {
      all: () => [],
      detail: (params: { id: string }) => [params.id],
    },
    posts: {
      all: () => [],
      detail: (params: { id: string }) => [params.id],
    },
  },
  v2: {
    users: {
      all: () => [],
      detail: (params: { id: string }) => [params.id],
    },
  },
});

// Use version-specific keys
useQuery({
  queryKey: queryKeys.v1.users.detail({ id: '123' }),
  queryFn: () => fetchUserV1('123'),
});

useQuery({
  queryKey: queryKeys.v2.users.detail({ id: '123' }),
  queryFn: () => fetchUserV2('123'),
});
```

---

## TypeScript Support

### Type Inference

The library provides full type inference. You don't need to manually specify types:

```typescript
const keys = createKeyFactory('app', {
  users: {
    detail: (params: { id: string }) => [params.id],
  },
});

// TypeScript knows the exact shape
keys.users.detail({ id: '123' }); // ✅ Type-safe
keys.users.detail({ id: 123 }); // ❌ Type error: id must be string
keys.users.detail({ wrong: '123' }); // ❌ Type error: wrong property
```

### Custom Types

You can define interfaces for your parameters:

```typescript
interface UserParams {
  id: string;
  includePosts?: boolean;
}

interface PostParams {
  id: string;
  includeComments?: boolean;
}

const queryKeys = createKeyFactory('app', {
  users: {
    detail: (params: UserParams) => [
      params.id,
      ...(params.includePosts ? ['posts'] : []),
    ],
  },
  posts: {
    detail: (params: PostParams) => [
      params.id,
      ...(params.includeComments ? ['comments'] : []),
    ],
  },
});
```

---

## Best Practices

### 1. Centralize Key Definitions

Create a single file for all your query keys:

```typescript
// src/lib/queryKeys.ts
import { createKeyFactory } from 'react-query-key-factory';

export const queryKeys = createKeyFactory('app', {
  // ... all your keys
});
```

### 2. Use Descriptive Names

```typescript
// ✅ Good
const keys = createKeyFactory('app', {
  users: {
    detail: (params: { id: string }) => [params.id],
  },
});

// ❌ Bad
const keys = createKeyFactory('a', {
  u: {
    d: (p: { i: string }) => [p.i],
  },
});
```

### 3. Group Related Keys

Organize keys by domain or feature:

```typescript
const queryKeys = createKeyFactory('app', {
  // Authentication
  auth: {
    currentUser: () => [],
    session: () => [],
  },
  // User management
  users: {
    all: () => [],
    detail: (params: { id: string }) => [params.id],
  },
  // Posts
  posts: {
    all: () => [],
    detail: (params: { id: string }) => [params.id],
  },
});
```

### 4. Use Array Shorthand for Static Keys

When keys don't need parameters, use array shorthand:

```typescript
// ✅ Good - array shorthand
const keys = createKeyFactory('app', {
  users: {
    all: [],
  },
});

// Also good - function with empty params
const keys = createKeyFactory('app', {
  users: {
    all: () => [],
  },
});
```

### 5. Leverage Intermediate Level Access

Use intermediate levels for query invalidation:

```typescript
// Invalidate all user-related queries
queryClient.invalidateQueries({
  queryKey: queryKeys.users(),
});

// Invalidate all post-related queries
queryClient.invalidateQueries({
  queryKey: queryKeys.posts(),
});
```

---

## FAQ

### Q: Can I use this with React Query v4 and v5?

A: Yes! This library works with all versions of React Query (TanStack Query) because it only generates key arrays, which is the standard format.

### Q: How do I handle optional parameters?

A: You can use optional properties in your parameter types:

```typescript
const keys = createKeyFactory('app', {
  users: {
    search: (params: { query: string; page?: number }) => [
      params.query,
      ...(params.page ? [params.page.toString()] : []),
    ],
  },
});
```

### Q: Can I use this with other query libraries?

A: Yes! While designed for React Query, this library generates standard key arrays that work with any library that uses array-based keys.

### Q: How do I handle special characters in keys?

A: Special characters are supported in key names:

```typescript
const keys = createKeyFactory('app', {
  'key-1': () => ['value'],
  'key_2': () => ['value2'],
});

keys['key-1']({}) // Works fine
```

### Q: What's the difference between array shorthand and functions?

A: Array shorthand is syntactic sugar for functions that return static arrays:

```typescript
// These are equivalent:
list: ['all']
list: () => ['all']
```

Use functions when you need dynamic values based on parameters.

### Q: Can I nest keys infinitely?

A: Yes, there's no limit to nesting depth. However, keep it reasonable for maintainability.

---

## License

MIT
